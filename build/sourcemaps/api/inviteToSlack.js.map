{"version":3,"sources":["api/inviteToSlack.js"],"names":[],"mappings":";;;;AAAA,IAAI,CAAC,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;;AAE/B,IAAI,QAAQ,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AACrC,IAAI,GAAG,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AAC5B,IAAI,QAAQ,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;AACtC,IAAI,CAAC,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC;AACjC,IAAI,SAAS,GAAG,OAAO,CAAC,aAAa,CAAC,CAAC;;AAEvC,SAAS,2BAA2B,CAAC,IAAI,EAAE;AACzC,MAAI,aAAa,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAClC,SAAO,aAAa,CAAC,oBAAoB,CAAC;AAC1C,SAAO,aAAa,CAAC,cAAc,CAAC;AACpC,SAAO,aAAa,CAAC;CACtB;;AAED,IAAI,gCAAgC,qBAAG,WAAgB,QAAQ,EAAE;AAC/D,MAAI,KAAK,GAAG,MAAM,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,EAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;AAChF,MAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;AACpB,WAAO,2BAA2B,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;GAC9C,MAAM;AACL,WAAO,IAAI,CAAC;GACb;CACF,CAAA,CAAC;;AAGF,MAAM,CAAC,OAAO,GAAG;AACf,KAAG,EAAE,yFAAyF;AAC9F,aAAW,oBAAE,WAAgB,GAAG,EAAE,IAAI,EAAE;QAEpC,IAAI,GAKF,IAAI,CALN,IAAI;QACJ,QAAQ,GAIN,IAAI,CAJN,QAAQ;QACR,cAAc,GAGZ,IAAI,CAHN,cAAc;QACd,KAAK,GAEH,IAAI,CAFN,KAAK;QACL,WAAW,GACT,IAAI,CADN,WAAW;;;AAIb,QAAI,KAAK,GAAG,SAAS,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;AACjD,QAAI,KAAK,KAAK,IAAI,EAAE;AAClB,YAAM,QAAQ,CAAC,kBAAkB,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;KAChD;;AAED,QAAI,oBAAoB,GAAG,QAAQ,CAAC,wBAAwB,CAAC,cAAc,CAAC,CAAC;;;;;;;;;;;;;;;;;;AAkB7E,QAAI,aAAa,GAAG,MAAM,CAAC,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,EAAC,QAAQ,EAAE,QAAQ,EAAC,CAAC,CAAC;;AAEvF,QAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;;;AAG5B,UAAI,YAAY,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACpC,UAAI,QAAQ,CAAC,qBAAqB,CAAC,cAAc,EAAE,YAAY,CAAC,oBAAoB,CAAC,EAAE;;AAErF,YAAI,IAAI,GAAG,MAAM,gCAAgC,CAAC,QAAQ,CAAC,CAAC;;AAE5D,eAAO;AACL,aAAG,EAAE,IAAI;AACT,cAAI,EAAE,IAAI,EACX,CAAC;OAEH,MAAM;;AAEL,cAAM,QAAQ,CAAC,oBAAoB,EAAE,GAAG,EAAE,4BAA4B,CAAC,CAAC;OACzE;KAEF,MAAM;AACL,YAAM,QAAQ,CAAC,uBAAuB,EAAE,GAAG,EAAE,6CAA6C,CAAC,CAAC;KAC7F;GAEF,CAAA;AACD,kCAAgC,EAAhC,gCAAgC,EACjC,CAAC","file":"api/inviteToSlack.js","sourcesContent":["var _ = require('lodash-node');\n\nvar ApiError = require('./ApiError');\nvar log = require('../log');\nvar password = require('../password');\nvar r = require('../database/r');\nvar username_ = require('../username');\n\nfunction sanitizeUserObjectForClient(user) {\n  var sanitizedUser = _.clone(user);\n  delete sanitizedUser.doubleHashedPassword;\n  delete sanitizedUser.hashedPassword;\n  return sanitizedUser;\n}\n\nvar getSanitizedUserforUsernameAsync = async function (username) {\n  var users = await r.db('exp_host').table('users').filter({username: username,});\n  if (users.length > 0) {\n    return sanitizeUserObjectForClient(users[0]);\n  } else {\n    return null;\n  }\n};\n\n\nmodule.exports = {\n  doc: \"Adds a user to the exp.host system; logs in a user if the user has already been created\",\n  methodAsync: async function (env, args) {\n    var {\n      name,\n      username,\n      hashedPassword,\n      email,\n      phoneNumber,\n    } = args;\n\n    // Validate username\n    var valid = username_.validateUsername(username);\n    if (valid !== true) {\n      throw ApiError('INVALID_USERNAME', env, valid);\n    }\n\n    var doubleHashedPassword = password.doubleHashHashedPassword(hashedPassword);\n\n    // Here is what this API method does:\n    // 1. Check to see if there already is a user with this username in the database\n    // 2. If there is, then see if the passwords match\n    // 3.     If the passwords do match, then update any fields that the user has provided\n    //        and return a message about a successful login\n    // 4.     If the passwords don't match, then throw an Error saying that the user already\n    //        exists but the passwords don't match\n    // 5. If there is no user with this username, create the user with the data provided and\n    //    return a successful login message\n    //\n\n    // TODO: Make this more robustly transactional\n    // TODO: Consider making this use sessions or something different than the password scheme\n    // we've set up (though I think using passwords is straightforward and simplest for now)\n\n    // 1. Check to see if a user with that name already exists\n    var existingUsers = await r.db('exp_host').table('users').filter({username: username});\n\n    if (existingUsers.length > 0) {\n\n      // 2. There is a user with this username, see if the passwords match\n      var existingUser = existingUsers[0];\n      if (password.hashedPasswordMatches(hashedPassword, existingUser.doubleHashedPassword)) {\n\n        var user = await getSanitizedUserforUsernameAsync(username);\n\n        return {\n          err: null,\n          user: user,\n        };\n\n      } else {\n        // 4. The passwords don't match, so return an error\n        throw ApiError('INCORRECT_PASSWORD', env, \"That password is incorrect\");\n      }\n\n    } else {\n      throw ApiError('NO_USER_WITH_USERNAME', env, \"There is no user with that username, sorry.\");\n    }\n\n  },\n  getSanitizedUserforUsernameAsync,\n};\n"],"sourceRoot":"/source/"}